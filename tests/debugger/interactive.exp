       1:      1  1 CALL pred interactive:main/2-0 (cc_multi) interactive.m:21
mdb> echo on
Command echo enabled.
mdb> print *
       HeadVar__1             	state('<<c_pointer>>')
mdb> 
       2:      2  2 CALL pred interactive:data/1-0 (det) interactive.m:40 (interactive.m:19)
mdb> print *
mdb: there are no live variables.
mdb> 
       3:      2  2 EXIT pred interactive:data/1-0 (det) interactive.m:40 (interactive.m:19)
mdb> print *
       HeadVar__1             	[1, 2, 3, 4, 5]
mdb> 
       4:      3  2 CALL pred interactive:queen/2-0 (nondet) interactive.m:42 (interactive.m:19)
mdb> print *
       HeadVar__1             	[1, 2, 3, 4, 5]
mdb> 
       5:      4  3 CALL pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:43)
mdb> print *
       HeadVar__1             	[1, 2, 3, 4, 5]
mdb> 
       6:      4  3 SWTC pred interactive:qperm/2-0 (nondet) s2; interactive.m:47
mdb> print *
       HeadVar__1             	[1, 2, 3, 4, 5]
mdb> 
       7:      5  4 CALL pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
mdb> print *
       HeadVar__2             	[1, 2, 3, 4, 5]
mdb> 
       8:      5  4 DISJ pred interactive:qdelete/3-0 (nondet) c2;d1; interactive.m:52
mdb> print *
       HeadVar__2             	[1, 2, 3, 4, 5]
mdb> level 1
Ancestor level set to 1:
   1  pred interactive:qperm/2-0 (nondet) interactive.m:48
mdb> print *
       HeadVar__1             	[1, 2, 3, 4, 5]
mdb> up 1
Ancestor level set to 2:
   2  pred interactive:queen/2-0 (nondet) interactive.m:43
mdb> vars
        1 HeadVar__1
mdb> print *
       HeadVar__1             	[1, 2, 3, 4, 5]
mdb> 
       9:      5  4 EXIT pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
mdb> print HeadVar__1
       HeadVar__1             	1
mdb> print HeadVar__2
       HeadVar__2             	[1, 2, 3, 4, 5]
mdb> print HeadVar__3
       HeadVar__3             	[2, 3, 4, 5]
mdb> 
      10:      6  4 CALL pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
mdb> print *
       HeadVar__1             	[2, 3, 4, 5]
mdb> 
      11:      6  4 SWTC pred interactive:qperm/2-0 (nondet) s2; interactive.m:47
mdb> print *
       HeadVar__1             	[2, 3, 4, 5]
mdb> 
      12:      7  5 CALL pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
mdb> print *
       HeadVar__2             	[2, 3, 4, 5]
mdb> 
      13:      7  5 DISJ pred interactive:qdelete/3-0 (nondet) c2;d1; interactive.m:52
mdb> print *
       HeadVar__2             	[2, 3, 4, 5]
mdb> 
      14:      7  5 EXIT pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
mdb> print *
       HeadVar__1             	2
       HeadVar__2             	[2, 3, 4, 5]
       HeadVar__3             	[3, 4, 5]
mdb> 
      15:      8  5 CALL pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
mdb> goto -a 20
      16:      8  5 SWTC pred interactive:qperm/2-0 (nondet) s2; interactive.m:47
      17:      9  6 CALL pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
      18:      9  6 DISJ pred interactive:qdelete/3-0 (nondet) c2;d1; interactive.m:52
      19:      9  6 EXIT pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
      20:     10  6 CALL pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
mdb> stack
   0    4* pred interactive:qperm/2-0 (nondet) (interactive.m:46 and others)
   4       pred interactive:queen/2-0 (nondet) (interactive.m:43)
   5       pred interactive:main/2-0 (cc_multi) (interactive.m:19)
mdb> stack -d
   0      20      10    6 pred interactive:qperm/2-0 (nondet) (interactive.m:46) (empty)
   1      15       8    5 pred interactive:qperm/2-0 (nondet) (interactive.m:50) s2;c2;
   2      10       6    4 pred interactive:qperm/2-0 (nondet) (interactive.m:50) s2;c2;
   3       5       4    3 pred interactive:qperm/2-0 (nondet) (interactive.m:50) s2;c2;
   4       4       3    2 pred interactive:queen/2-0 (nondet) (interactive.m:43) c2;
   5       1       1    1 pred interactive:main/2-0 (cc_multi) (interactive.m:19) ?;c2;q!;
mdb> print *
       HeadVar__1             	[4, 5]
mdb> #
Unknown command `#'. Give the command `help' for help.
mdb> # Test interactive queries.
Unknown command `#'. Give the command `help' for help.
mdb> #
Unknown command `#'. Give the command `help' for help.
mdb> mmc_options --use-subdirs
mdb> mmc_options
mdb> query interactive list
?- <stdin>:026: Inferred :- pred query((list:list(character)), (list:list(character))).
<stdin>:026: Inferred :- mode query(out, out) is multi.
append(X, Y, ['a', 'b', 'c']).
X = [], Y = ['a', 'b', 'c'], true ;
X = ['a'], Y = ['b', 'c'], true ;
X = ['a', 'b'], Y = ['c'], true ;
X = ['a', 'b', 'c'], Y = [], true ;
fail.
No (more) solutions.
?- <stdin>:026: Inferred :- pred query((list:list(int))).
<stdin>:026: Inferred :- mode query(out) is nondet.
qperm([1,2,3], List).
List = [1, 2, 3], true ;
List = [1, 3, 2], true ;
List = [2, 1, 3], true ;
List = [2, 3, 1], true ;
List = [3, 1, 2], true ;
List = [3, 2, 1], true ;
fail.
No (more) solutions.
?- <stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:014: In clause for predicate `query:run/2':
<stdin>:014:   warning: variable `_2' occurs more than once in this scope.
<stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:015: In clause for predicate `query:run/2':
<stdin>:015:   warning: variable `_2' occurs more than once in this scope.
<stdin>:026: In clause for predicate `query:query/2':
<stdin>:026:   warning: variable `_2' occurs more than once in this scope.
<stdin>:001: In clause for predicate `query:query/2':
<stdin>:001:   warning: variable `_2' occurs more than once in this scope.
<stdin>:026: Inferred :- pred query((list:list(int)), (list:list(int))).
<stdin>:026: Inferred :- mode query(out, out) is nondet.
qperm([1,2,3], List), List = [2 | _].
List = [2, 1, 3], _2 = [1, 3], true ;
List = [2, 3, 1], _2 = [3, 1], true ;
fail.
No (more) solutions.
?- <stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:014: In clause for predicate `query:run/2':
<stdin>:014:   warning: variable `_2' occurs more than once in this scope.
<stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:015: In clause for predicate `query:run/2':
<stdin>:015:   warning: variable `_2' occurs more than once in this scope.
<stdin>:026: In clause for predicate `query:query/2':
<stdin>:026:   warning: variable `_2' occurs more than once in this scope.
<stdin>:001: In clause for predicate `query:query/2':
<stdin>:001:   warning: variable `_2' occurs more than once in this scope.
<stdin>:026: Inferred :- pred query((list:list(int)), (list:list(int))).
<stdin>:026: Inferred :- mode query(out, out) is nondet.
qperm([1,2,3], List), List = [4 | _].
fail.
No (more) solutions.
?- <stdin>:001: In clause for predicate `query:query/1':
<stdin>:001:   in argument 1 of call to predicate `qperm/2':
<stdin>:001:   in argument 2 of functor `[|]/2':
<stdin>:001:   in argument 2 of functor `[|]/2':
<stdin>:001:   in argument 1 of functor `[|]/2':
<stdin>:001:   type error in unification of argument
<stdin>:001:   and constant `"foo"'.
<stdin>:001:   argument has type `int',
<stdin>:001:   constant `"foo"' has type `string'.
For more information, try recompiling with `-E'.
qperm([1,2,"foo"], List).
Compilation error(s) occurred.
?- <stdin>:026: Inferred :- pred query((list:list(int))).
<stdin>:014: In clause for `run(di, uo)':
<stdin>:014:   in call to predicate `query:query/1':
<stdin>:014:   mode error: arguments `List'
<stdin>:014:   have insts `free',
<stdin>:014:   which does not match any of the valid modes for
<stdin>:014:   the callee, because of the following error.
<stdin>:026: In clause for `query(out(not_reached))':
<stdin>:026:   in argument 1 of call to predicate `interactive:qperm/2':
<stdin>:026:   mode error: variable `HeadVar__2' has instantiatedness `free',
<stdin>:026:   expected instantiatedness was `ground'.
For more information, try recompiling with `-E'.
qperm(List, [1]).
Compilation error(s) occurred.
?- quit.

mdb> cc_query interactive list
?- <stdin>:017: Inferred :- pred query((list:list(character)), (list:list(character))).
<stdin>:017: Inferred :- mode query(out, out) is multi.
append(X, Y, ['a', 'b', 'c']).
X = [], Y = ['a', 'b', 'c'], true.
?- <stdin>:017: Inferred :- pred query((list:list(int))).
<stdin>:017: Inferred :- mode query(out) is nondet.
qperm([1,2,3], List).
List = [1, 2, 3], true.
?- <stdin>:011: In clause for predicate `query:run/2':
<stdin>:011:   warning: variable `_2' occurs more than once in this scope.
<stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:017: In clause for predicate `query:query/2':
<stdin>:017:   warning: variable `_2' occurs more than once in this scope.
<stdin>:001: In clause for predicate `query:query/2':
<stdin>:001:   warning: variable `_2' occurs more than once in this scope.
<stdin>:017: Inferred :- pred query((list:list(int)), (list:list(int))).
<stdin>:017: Inferred :- mode query(out, out) is nondet.
qperm([1,2,3], List), List = [2 | _].
List = [2, 1, 3], _2 = [1, 3], true.
?- <stdin>:011: In clause for predicate `query:run/2':
<stdin>:011:   warning: variable `_2' occurs more than once in this scope.
<stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:017: In clause for predicate `query:query/2':
<stdin>:017:   warning: variable `_2' occurs more than once in this scope.
<stdin>:001: In clause for predicate `query:query/2':
<stdin>:001:   warning: variable `_2' occurs more than once in this scope.
<stdin>:017: Inferred :- pred query((list:list(int)), (list:list(int))).
<stdin>:017: Inferred :- mode query(out, out) is nondet.
qperm([1,2,3], List), List = [4 | _].
No solution.
?- quit.

mdb> io_query interactive list
run <-- main.
[1, 3, 5, 2, 4]
run <-- if { append(X, Y, ['a', 'b', 'c']) } then print("X = "), print(X), print(", Y = "), print(Y), nl else print("No solution\n").
X = [], Y = ['a', 'b', 'c']
run <-- if { qperm([1,2,3], List) } then print(List), nl else [].
[1, 2, 3]
run <-- if { qperm([1,2,3], List), List = [2 | _] } then print(List), nl else { true }.
[2, 1, 3]
run <-- if { qperm([1,2,3], List), List = [4 | _] } then print(List), nl else print("No solution, as expected."), io__nl.
No solution, as expected.
run <-- quit.

mdb> retry
This command is a no-op from this port.
mdb> print *
       HeadVar__1             	[4, 5]
mdb> finish -a
      21:     10  6 SWTC pred interactive:qperm/2-0 (nondet) s2; interactive.m:47
      22:     11  7 CALL pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
      23:     11  7 DISJ pred interactive:qdelete/3-0 (nondet) c2;d1; interactive.m:52
      24:     11  7 EXIT pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
      25:     12  7 CALL pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      26:     12  7 SWTC pred interactive:qperm/2-0 (nondet) s2; interactive.m:47
      27:     13  8 CALL pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
      28:     13  8 DISJ pred interactive:qdelete/3-0 (nondet) c2;d1; interactive.m:52
      29:     13  8 EXIT pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
      30:     14  8 CALL pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      31:     14  8 SWTC pred interactive:qperm/2-0 (nondet) s1; interactive.m:46
      32:     14  8 EXIT pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      33:     12  7 EXIT pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      34:     10  6 EXIT pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
mdb> register --quiet
mdb> break print_list
 0: + stop  interface pred interactive:print_list/3-0 (det)
mdb> break qdelete
 1: + stop  interface pred interactive:qdelete/3-0 (nondet)
mdb> continue -a
      35:      8  5 EXIT pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      36:      6  4 EXIT pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      37:      4  3 EXIT pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:43)
      38:     15  3 CALL pred interactive:safe/1-0 (semidet) interactive.m:56 (interactive.m:44)
      39:     15  3 SWTC pred interactive:safe/1-0 (semidet) s2; interactive.m:57
      40:     16  4 CALL pred interactive:nodiag/3-0 (semidet) interactive.m:61 (interactive.m:58)
      41:     16  4 SWTC pred interactive:nodiag/3-0 (semidet) s2; interactive.m:62
      42:     16  4 THEN pred interactive:nodiag/3-0 (semidet) s2;c4;t; interactive.m:66
      43:     16  4 FAIL pred interactive:nodiag/3-0 (semidet) interactive.m:61 (interactive.m:58)
      44:     15  3 FAIL pred interactive:safe/1-0 (semidet) interactive.m:56 (interactive.m:44)
      45:      4  3 REDO pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:43)
      46:      6  4 REDO pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      47:      8  5 REDO pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      48:     10  6 REDO pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      49:     12  7 REDO pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      50:     14  8 REDO pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      51:     14  8 FAIL pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
      52:     13  8 REDO pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
mdb> step -aS 5
      53:     13  8 DISJ pred interactive:qdelete/3-0 (nondet) c2;d2; interactive.m:53
      54:     17  9 CALL pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:54)
      55:     17  9 FAIL pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:54)
      56:     13  8 FAIL pred interactive:qdelete/3-0 (nondet) interactive.m:52 (interactive.m:48)
      57:     12  7 FAIL pred interactive:qperm/2-0 (nondet) interactive.m:46 (interactive.m:50)
mdb> disable 1
 1: - stop  interface pred interactive:qdelete/3-0 (nondet)
mdb> continue -n
     675:    141  2 CALL pred interactive:print_list/3-0 (det) interactive.m:83 (interactive.m:20)
mdb> continue -n -S
[1, 3, 5, 2, 4]
