#-----------------------------------------------------------------------------#

main_target:	check

include ../../Mmake.common
-include ../../Mmake.params

#-----------------------------------------------------------------------------#

# We suppress the printing of the banner, because different workspaces
# may get different version numbers printed in it. This would otherwise be
# the source of irrelevant difference between the actual and expected outputs.

MDB = MERCURY_SUPPRESS_MDB_BANNER=yes mdb

#-----------------------------------------------------------------------------#

DECLARATIVE_PROGS=		\
	aadebug			\
	app			\
	args			\
	backtrack		\
	big			\
	browse_arg		\
	comp_gen		\
	deep_warning		\
	dependency		\
	dependency2		\
	family			\
	filter			\
	func_call		\
	gcf			\
	higher_order		\
	ho2			\
	if_then_else		\
	input_term_dep		\
	ite_2			\
	lpe_example		\
	neg_conj		\
	negation		\
	oracle_db		\
	output_term_dep		\
	propositional		\
	queens			\
	small			\
	special_term_dep	\
	throw

# The following should not be run in `debug' grades.
NONDEBUG_DECLARATIVE_PROGS=	\
	untraced_subgoal

NONWORKING_DECLARATIVE_PROGS=	\
	solutions

MCFLAGS += --trace decl
MLFLAGS += --trace

MCFLAGS-deep_sub=--trace deep
MCFLAGS-dependency=--trace rep
MCFLAGS-dependency2=--trace rep
MCFLAGS-input_term_dep=--trace rep
MCFLAGS-output_term_dep=--trace rep
MCFLAGS-special_term_dep=--trace rep
MCFLAGS-untraced_subgoal_sub=--trace minimum

ifneq "$(findstring .debug,$(GRADE))" ""
    PROGS_2=$(DECLARATIVE_PROGS)
else
    PROGS_2=$(DECLARATIVE_PROGS) $(NONDEBUG_DECLARATIVE_PROGS)
endif

# Debugging does not work in MLDS (hl*) and deep profiling (profdeep) grades.
# Base grades `jump' and `fast' cannot be used with
# stack layouts (which are required for tracing).
# Currently, declarative debugging does not work in `rt' grades.
# Also, declarative debugging only works in `.gc' grades.

ifeq "$(findstring hl,$(GRADE))$(findstring profdeep,$(GRADE))" ""
    ifneq "$(findstring .gc,$(GRADE))" ""
        ifneq "$(findstring rt,$(GRADE))" ""
	    PROGS=
        else
            ifneq "$(findstring asm_,$(GRADE))" ""
                PROGS=$(PROGS_2)
            else
                ifneq "$(findstring jump,$(GRADE))" ""
                    PROGS=
                else
                    ifneq "$(findstring fast,$(GRADE))" ""
                        PROGS=
                    else
                        PROGS=$(PROGS_2)
                    endif
                endif
            endif
        endif
    else
        PROGS=
    endif
else
    PROGS=
endif

#-----------------------------------------------------------------------------#

aadebug.out: aadebug aadebug.inp
	$(MDB) ./aadebug < aadebug.inp > aadebug.out 2>&1

app.out: app app.inp
	$(MDB) ./app < app.inp > app.out 2>&1

args.out: args args.inp
	$(MDB) ./args < args.inp > args.out 2>&1

backtrack.out: backtrack backtrack.inp
	$(MDB) ./backtrack < backtrack.inp > backtrack.out 2>&1

big.out: big big.inp
	$(MDB) ./big < big.inp > big.out 2>&1

browse_arg.out: browse_arg browse_arg.inp
	$(MDB) ./browse_arg < browse_arg.inp > browse_arg.out 2>&1

comp_gen.out: comp_gen comp_gen.inp
	$(MDB) ./comp_gen < comp_gen.inp > comp_gen.out 2>&1

deep_warning.out: deep_warning deep_warning.inp
	$(MDB) ./deep_warning < deep_warning.inp > deep_warning.out 2>&1

dependency.out: dependency dependency.inp
	$(MDB) ./dependency < dependency.inp > dependency.out 2>&1

dependency2.out: dependency2 dependency2.inp
	$(MDB) ./dependency2 < dependency2.inp > dependency2.out 2>&1

family.out: family family.inp
	$(MDB) ./family < family.inp > family.out 2>&1

filter.out: filter filter.inp
	$(MDB) ./filter < filter.inp > filter.out 2>&1

func_call.out: func_call func_call.inp
	$(MDB) ./func_call < func_call.inp > func_call.out 2>&1

gcf.out: gcf gcf.inp
	$(MDB) ./gcf < gcf.inp > gcf.out 2>&1

higher_order.out: higher_order higher_order.inp
	$(MDB) ./higher_order < higher_order.inp > higher_order.out 2>&1

ho2.out: ho2 ho2.inp
	$(MDB) ./ho2 < ho2.inp > ho2.out 2>&1

if_then_else.out: if_then_else if_then_else.inp
	$(MDB) ./if_then_else < if_then_else.inp > if_then_else.out 2>&1

input_term_dep.out: input_term_dep input_term_dep.inp
	$(MDB) ./input_term_dep < input_term_dep.inp > input_term_dep.out 2>&1

ite_2.out: ite_2 ite_2.inp
	$(MDB) ./ite_2 < ite_2.inp > ite_2.out 2>&1

lpe_example.out: lpe_example lpe_example.inp
	$(MDB) ./lpe_example < lpe_example.inp > lpe_example.out 2>&1

neg_conj.out: neg_conj neg_conj.inp
	$(MDB) ./neg_conj < neg_conj.inp > neg_conj.out 2>&1

negation.out: negation negation.inp
	$(MDB) ./negation < negation.inp > negation.out 2>&1

oracle_db.out: oracle_db oracle_db.inp
	$(MDB) ./oracle_db < oracle_db.inp > oracle_db.out 2>&1

output_term_dep.out: output_term_dep output_term_dep.inp
	$(MDB) ./output_term_dep < output_term_dep.inp	\
			> output_term_dep.out 2>&1

propositional.out: propositional propositional.inp
	$(MDB) ./propositional < propositional.inp > propositional.out 2>&1

queens.out: queens queens.inp
	$(MDB) ./queens < queens.inp > queens.out 2>&1

small.out: small small.inp
	$(MDB) ./small < small.inp > small.out 2>&1

solutions.out: solutions solutions.inp
	$(MDB) ./solutions < solutions.inp > solutions.out 2>&1

special_term_dep.out: special_term_dep special_term_dep.inp
	$(MDB) ./special_term_dep < special_term_dep.inp \
			> special_term_dep.out 2>&1

# We need to pipe the output through sed to avoid hard-coding dependencies on
# particular line numbers in the standard library source code.
throw.out: throw throw.inp
	$(MDB) ./throw < throw.inp 2>&1 | \
		sed -e 's/exception.m:[0-9]*/exception.m:NNNN/g' | \
		sed -e '/EXCP/s/).*/)/' > throw.out 2>&1

untraced_subgoal.out: untraced_subgoal untraced_subgoal.inp
	$(MDB) ./untraced_subgoal < untraced_subgoal.inp \
			> untraced_subgoal.out 2>&1

#-----------------------------------------------------------------------------#

DEPS=		$(PROGS:%=$(deps_subdir)%.dep)
DEPENDS=	$(PROGS:%=%.depend)
OUTS=		$(PROGS:%=%.out)
RESS=		$(PROGS:%=%.res)

#-----------------------------------------------------------------------------#

dep:		$(DEPS)

depend:		$(DEPENDS)

check:		$(OUTS) $(RESS)

all:		$(PROGS)

#-----------------------------------------------------------------------------#
