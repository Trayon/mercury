#-----------------------------------------------------------------------------#

main_target: check

include ../Mmake.common
-include ../Mmake.params

#-----------------------------------------------------------------------------#

# Note: multi-module tests (including tests of nested modules)
# need to be listed separately from single-module tests, since
# we need to make dependencies only for multimodule tests.
# However, multi-module tests where the error is detected when
# building the dependencies (e.g. duplicate_module_test.m) should 
# not be included in this list; we handle those specially (see below).

MULTIMODULE_SOURCES= \
	aditi_errors.m \
	aditi_state_errors.m \
	aditi_update_derived_relation.m \
	aditi_update_errors.m \
	aditi_update_mode_errors.m \
	duplicate_instance_2.m \
	ho_default_func_2.sub.m \
	imported_mode.m \
	partial_implied_mode.m \
	sub_c.m \
	test_nested.m \
	transitive_import.m \
	transitive_import_class.m \
	undef_mod_qual.m

SINGLEMODULE_SOURCES= \
	any_mode.m \
	assert_in_interface.m \
	bigtest.m \
	bind_var_errors.m \
	builtin_int.m \
	builtin_proc.m \
	circ_type.m \
	constrained_poly_insts.m \
	constructor_warning.m \
	det_errors.m \
	duplicate_modes.m \
	duplicate_module_test.m \
	errors.m \
	errors1.m \
	errors2.m \
	external.m \
	ext_type.m \
	ext_type_bug.m \
	exported_mode.m \
	field_syntax_error.m \
	func_errors.m \
	funcs_as_preds.m \
	ho_default_func_1.m \
	ho_default_func_3.m \
	ho_type_mode_bug.m \
	ho_unique_error.m \
	impure_method_impl.m \
	inline_conflict.m \
	inst_list_dup.m \
	invalid_main.m \
	invalid_typeclass.m \
	io_in_ite_cond.m \
	lambda_syntax_error.m \
	merge_ground_any.m \
	method_impl.m \
	missing_det_decls.m \
	missing_interface_import.m \
	mode_inf.m \
	modes_erroneous.m \
	mostly_uniq1.m \
	mostly_uniq2.m \
	multimode_missing_impure.m \
	multimode_dcg.m \
	multimode_syntax.m \
	multisoln_func.m \
	nested_impl_in_int.m \
	no_exports.m \
	not_a_switch.m \
	nullary_ho_func_error.m \
	occurs.m \
	overloading.m \
	polymorphic_unification.m \
	pragma_c_code_and_clauses1.m \
	pragma_c_code_and_clauses2.m \
	pragma_c_code_dup_var.m \
	pragma_c_code_no_det.m \
	predmode.m \
	prog_io_erroneous.m \
	qual_basic_test2.m \
	qualified_cons_id2.m \
	record_syntax_errors.m \
	some.m \
	spurious_mode_error.m \
	tc_err1.m \
	tc_err2.m \
	tricky_assert1.m \
	type_inf_loop.m \
	type_loop.m \
	type_mismatch.m \
	type_vars.m \
	typeclass_bogus_method.m \
	typeclass_mode.m \
	typeclass_missing_det.m \
	typeclass_missing_det_2.m \
	typeclass_missing_det_3.m \
	typeclass_missing_mode.m \
	typeclass_missing_mode_2.m \
	typeclass_test_1.m \
	typeclass_test_2.m \
	typeclass_test_3.m \
	typeclass_test_4.m \
	typeclass_test_5.m \
	typeclass_test_7.m \
	typeclass_test_9.m \
	types.m	\
	type_spec.m \
	unbound_type_vars.m \
	undef_lambda_mode.m \
	undef_mode.m \
	undef_mode_and_no_clauses.m \
	undef_symbol.m \
	undef_type.m \
	undef_type_mod_qual.m \
	unify_mode_error.m \
	uniq_modes.m \
	uniq_neg.m \
	uu_type.m \
	vars_in_wrong_places.m \
	with_type.m

SOURCES= $(SINGLEMODULE_SOURCES) $(MULTIMODULE_SOURCES)

# we do not yet pass the following tests:
#	duplicate_instance_3 (the error is only detected when doing
#		normal static linking; the error goes undetected
#		when doing dynamic linking, or when the library
#		was built with `--split-c-files')
#	parent.undeclared_child.m (just not yet implemented)
#	freefree.m 	(need bromage's aliasing stuff)
#	typeclass_test_8.m (minor formatting error in the output --
#			the type class name should be in quotes)
#	typeclass_mode_{2,3,4}.m (compiler calls error/1)
#	cyclic_typeclass.m (compiler goes into an infinite loop)
#	ho_default_func_4.m (due to a bug in the mode-checker ---
#			see XXX comment in inst_match:inst_matches_final_3)
#	inst_matches_final_bug.m (due to same bug as ho_default_func_4.m)

# Inter-module optimization changes the diagnostics for some
# tests (in most cases reporting diagnostics when writing the `.opt'
# file). For those tests, we just disable inter-module optimization.

MCFLAGS-aditi_errors =		--aditi --no-intermodule-optimization
MCFLAGS-aditi_state_errors =	--aditi --no-intermodule-optimization
MCFLAGS-aditi_update_derived_relation =	--aditi --no-intermodule-optimization
MCFLAGS-aditi_update_errors =	--aditi --no-intermodule-optimization
MCFLAGS-aditi_update_mode_errors = --aditi --no-intermodule-optimization
MCFLAGS-any_mode	=	--infer-types

# XXX This test should work with --intermodule-optimization, but
# the compiler doesn't know whether items imported from `.opt' files
# were imported in the interface or the implementation. The error
# is reported correctly when building the `.opt' file.
MCFLAGS-assert_in_interface =	--no-intermodule-optimization

MCFLAGS-duplicate_modes	=	--verbose-error-messages
MCFLAGS-exported_mode =		--infer-all --no-intermodule-optimization
MCFLAGS-imported_mode =		--infer-all --no-intermodule-optimization
MCFLAGS-missing_det_decls =	--no-infer-det
MCFLAGS-missing_interface_import = --make-interface
MCFLAGS-multisoln_func	=	--infer-types
MCFLAGS-mode_inf	=	--infer-all
MCFLAGS-no_exports = 		--halt-at-warn
MCFLAGS-overloading = 		--no-intermodule-optimization
MCFLAGS-sub_c = 	--verbose-error-messages --no-intermodule-optimization
MCFLAGS-record_syntax_errors =	--verbose-error-messages
MCFLAGS-test_nested =		--no-intermodule-optimization
MCFLAGS-transitive_import = --no-intermodule-optimization
MCFLAGS-transitive_import2 = --no-intermodule-optimization
MCFLAGS-transitive_import_class = --no-intermodule-optimization
MCFLAGS-transitive_import_class2 = --no-intermodule-optimization
MCFLAGS-transitive_import_class3 = --no-intermodule-optimization
MCFLAGS-typeclass_mode =	--infer-all
MCFLAGS-undef_mod_qual = 	--no-intermodule-optimization
MCFLAGS-undef_symbol = 		--no-intermodule-optimization

# For these test cases, the bug is caught when generating dependencies,
# so it is easiest just to do that step.
MCFLAGS-nested_impl_in_int =	--generate-dependencies
MCFLAGS-duplicate_module_test =	--generate-dependencies

MULTIMODULE_DEPENDS=	$(MULTIMODULE_SOURCES:%.m=%.depend)

ERRS=		$(SOURCES:%.m=%.err)
ERR_RESS=	$(SOURCES:%.m=%.err_res)

%.err: %.m
	if $(MC) $(ALL_GRADEFLAGS) $(ALL_MCFLAGS) --errorcheck-only $* \
		> $*.err 2>&1; \
	then false; else true; fi

# For duplicate_instance_{1,2}, the error is only caught at link time.
# So we need to use a different rule for that.
# The exact error message varies a lot from system to system,
# so we don't check the error output, we just check the command
# return status.
duplicate_instance_2.err: duplicate_instance_1.m duplicate_instance_2.m \
		$(ints_subdir)duplicate_instance_1.int
	if $(MC) $(ALL_GRADEFLAGS) $(ALL_MCFLAGS) \
		--link-flags "$(ALL_MLFLAGS)" \
		duplicate_instance_1.m duplicate_instance_2.m \
		> $*.err 2>&1; \
	then	false; \
	else	echo "Error was successfully detected" > $*.err; \
	fi

$(dates_subdir)undef_mod_qual.date: $(int0s_subdir)undef_mod_qual.int0

# Some tests have more than one possible valid output, so
# we allow the test to pass if it matches any of the .err_exp* files.
DIFF_OPTS=-c
%.err_res: %.err %.err_exp
	-rm -f $@
	diff $(DIFF_OPTS) $*.err_exp $*.err > $@ || \
		{ [ -f $*.err_exp2 ] && \
		  diff $(DIFF_OPTS) $*.err_exp2 $*.err > $@; } || \
		{ [ -f $*.err_exp3 ] && \
		  diff $(DIFF_OPTS) $*.err_exp3 $*.err > $@; } || \
		{ [ -f $*.err_exp4 ] && \
		  diff $(DIFF_OPTS) $*.err_exp4 $*.err > $@; }

all:	check

check:	$(ERRS) $(ERR_RESS)

errs:	$(ERRS)

depend:	$(MULTIMODULE_DEPENDS)

clean_local:
	rm -f *.err *.err_res

#-----------------------------------------------------------------------------#

SUBDIRS = purity

dep_subdirs:
	+for dir in $(SUBDIRS); do \
		(cd $$dir && $(SUBDIR_MMAKE) dep) || exit 1; \
	done

depend_subdirs:
	+for dir in $(SUBDIRS); do \
		(cd $$dir && $(SUBDIR_MMAKE) depend) || exit 1; \
	done

check_subdirs:
	+for dir in $(SUBDIRS); do \
		(cd $$dir && $(SUBDIR_MMAKE) check) || exit 1; \
	done

all_subdirs:
	+for dir in $(SUBDIRS); do \
		(cd $$dir && $(SUBDIR_MMAKE) all) || exit 1; \
	done

clean_subdirs:
	+for dir in $(SUBDIRS); do \
		(cd $$dir && $(SUBDIR_MMAKE) clean) || exit 1; \
	done

realclean_subdirs:
	+for dir in $(SUBDIRS); do \
		(cd $$dir && $(SUBDIR_MMAKE) realclean) || exit 1; \
	done

#-----------------------------------------------------------------------------#
