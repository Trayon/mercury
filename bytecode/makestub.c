
/*
** Copyright (C) 1997 University of Melbourne.
** This file may only be copied under the terms of the GNU Library General
** Public License - see the file COPYING.LIB in the Mercury distribution.
**
** $Id: makestub.c,v 1.1.2.1 1997-09-29 09:00:47 aet Exp $
*/

/*
**	Create a stubs file from a bytecode file.
**	For each procedure in the bytecode file, create a
**	C function which simply calls the call_bytecode() function
**	of the bytecode interpreter with arguments that correspond
**	to the bytecode procedure.
*/

/* Imports */

#include	<stdio.h>
#include	<stdlib.h>
#include	<assert.h>
#include	<unistd.h>
#include	<getopt.h>

#include	"util.h"
#include	"disasm.h"
#include	"makestub.h"

/* Exported definitions */

/* Local declarations */

static void
usage(void);

static char*
program_name	= NULL;

static void
MB_makestubs(FILE *fp, char *filename);

static char
rcs_id[]	= "$Id: makestub.c,v 1.1.2.1 1997-09-29 09:00:47 aet Exp $";

static const char*
text01[] = {
	"/*",
	"** This program is automatically generated by makestubs.",
	"** Do not edit.",
	"*/",
	"",
	"#include \"machine.h\" "
};

/* Implementation */

static void
MB_makestubs(FILE *fp, char *filename)
{
	MB_Short	bytecode_version_number = 0;
	MB_Bytecode	bytecode;

	/* Read two-byte version number */
	if (MB_read_bytecode_version_number(fp, &bytecode_version_number)) {
		printf("bytecode_version %d\n", bytecode_version_number);
		/* XXX: We should check the version number is 
		** what we expect. Should use major and minor version
		** numbers? Should use a magic number?
		** Should have the module name in the bytecode.
		*/
	} else {
		MB_fatal("Failed to read bytecode version number");
	}

	while (MB_read_bytecode(fp, &bytecode)) {
		if (BC_enter_proc == bytecode.id) {
		}
	} 
} /* end MB_makestubs() */

/*
** XXX: Do the following:
**	- open bytecode file
**	- read bytecode version number and check it
**	- read bytecodes
**		- on enter_pred change current pred.
**		- on enter_proc, create stub function
** XXX: N.B.
**	- context such as registers must also be saved and
**	  restored on calls.
*/
int
main(int argc, char* argv[])
{
	int	c;

	/* We do this in case we change the program name. */
	program_name = argv[0];

	/* Don't use default error messages from getopt() */
	opterr = 0;

	/* Read options */
	while ((c = getopt(argc,argv,"h")) != EOF) {
		switch (c) {
			case 'h':
				usage();
				exit(EXIT_SUCCESS);
				break;
			default:
				usage();
				exit(EXIT_FAILURE);
				break;
		}
	}

	/* 
	** If no arguments, then give an return with error since we need
	** a filename.
	*/
	if (optind == argc) {
		usage();
		exit(EXIT_FAILURE);
	} else {
		/* Process each bytecode file in order */
		int 	i;
		char	*filename;
		FILE	*fp;

		for (i = optind; i < argc; i++) {
			filename = argv[i];
			if (! MB_has_extension(filename, ".mbc"))
			{
				MB_util_error("file `%s' does not have .mbc "
					"extension");
			}
			else if ((fp = fopen(filename, "r")) != NULL) {
				MB_makestubs(fp, filename);
			} else {
				/* XXX: Give better error message */
				MB_util_error("can not open bytecode file `%s'",					filename);
			}
		}
	} /* end else */

	return EXIT_SUCCESS;
} /* end main() */


static void
usage(void)
{
	fprintf(stderr, "usage: %s [-h] files\n", program_name);
}
