- undefined insts/modes cause spurious flow-on errors

- the name mangling code needs to be generalized

- The --static-ground-terms sometimes causes duplicate labels in the
  generated C code.  Example:

:- pred special_pred_info(special_pred_id, type, string, list(type),
			list(mode), determinism).
:- mode special_pred_info(in, in, out, out, out, out) is det.

special_pred_info(unify, Type, "__Unify__", [Type, Type], [In, In], semidet) :-
	In = (ground -> ground).
special_pred_info(index, Type, "__Index__", [Type, IntType], [In, Out], det) :-
	term__context_init(Context),
	IntType = term__functor(term__atom("int"), [], Context),
	In = (ground -> ground),
	Out = (free -> ground).
special_pred_info(compare, Type,
		 "__Compare__", [ResType, Type, Type], [Out, In, In], det) :-
	term__context_init(Context),
	ResType = term__functor(term__atom("comparison_result"), [], Context),
	In = (ground -> ground),
	Out = (free -> ground).

- The followcode transformation is buggy, in that it can make valid
  code become invalid due to determinism errors.  We need to fix
  this by running determinism analysis once before followcode
  to check for errors, and then running it again after followcode
  this time ignoring any errors.  Or alternately we could put more
  intelligence into the followcode transformation pass so that it doesn't
  apply the transformation if it would introduce a determinism error.
  This has never occurred in practice, so it is a very low priority.

- Similarly, inlining flattens conjs which may introduce detism errors.

- The output of polymorphism is not in super-homogeneous form.
  e.g. unification of pair/1.  This does not cause any known bugs
  at this time, since the code generator can handle that, but it
  should be fixed at some stage.

