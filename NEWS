Work in progress
----------------

* There is a new `--generate-bytecode' option --
  but the bytecode interpreter isn't working yet.

* There is a new `--generate-prolog' option
  which does not work yet.

* There is a new `--optimize-constructor-last-call' option
  which identifies opportunities for LCO where a call
  is followed only by some constructor invocations.
  However, these opportunities are not exploited yet.

* We now allow programmers to give names to the arguments of constructor
  function symbols. XXX

* Support for big tables of facts. XXX

* Tabling/memoing of det and semidet predicates. XXX

DRAFT NEWS for Mercury release 0.7
----------------------------------

* The Mercury language now supports higher-order syntax.

  You can now write `P(X)' as an alternative to `call(P, X)'
  or `F(X)' as an alternative for `apply(F, X)'.

* Module qualifiers are now optional.

  You can use just plain `write_string' rather than `io__write_string'.

* There is a new `:- use_module' directive.

  This is the same as `:- import_module', except all uses of the imported
  items must be explicitly module qualified.

  More changes to the module system are expected in the future,
  including changing the module qualifier operator to `.'
  (currently either `:' or `__' can be used as module qualifiers).

* We've improved the C interface.

  The C interface now handles Mercury functions properly --
  previously it only handled predicates, not functions. 
  Also, exporting semidet predicates or functions to C now works
  (see `samples/c_interface/c_calls_mercury.m' for some examples).
  We've included some examples of how to use the C interface
  to interface with C++.

* We now support cross-module optimizations.

  The `--intermodule-optimization' option enables cross-module inlining
  and cross-module specialization of higher-order predicates.
  Also `--intermod-unused-args' enables cross-module elimination of
  unused input arguments.

* We've continued to improve the quality of the code we generate.

  We now use a more efficient argument-passing convention, and the code
  we generate for polymorphic predicates uses a more efficient "type-info"
  representation than previous versions. 

  (Note that this means code generated by Mercury 0.7 is not compatible
  with code generated by earlier versions, so you will need to
  recompile any existing Mercury object files or libraries when you
  install the new version.)

  We handle floating point code a bit better.  We don't box floating
  point values on 64-bit architectures anymore, and on 32-bit
  architectures we do a better job of avoiding unnecessary box/unbox
  operations.  We also make some use of floating point registers for
  holding temporary values.

  We've made several improvements to the code generator that result in
  better code in common situations.

  There's also a new optimization option, `--inline-alloc', which can
  speed up code that does a lot of memory allocation by inlining the
  GC_malloc() function.  (This option is also enabled by `-O6'.)

* We now support ELF shared libraries on Linux.

  See README.Linux for details.

  Note that using shared libraries is not yet the default,
  so if you want to take advantage of this, you must explicitly
  enable it as described in README.Linux.

* We have fixed quite a few bugs.

  Mode inference now works a little bit better. 
  
  We now allow a function of arity N to coexist with a predicate of
  arity N+1.

  The Mercury `char' type is now 8-bit clean (previously, "for
  compatibility with NU-Prolog" we only supported 7-bit characters).

* We've added `man' pages.

  The documentation now includes Unix-style `man' pages for
  most of the development tools, including mmake, mc, mgnuc, ml,
  and mprof.  These supplement the existing documentation in the
  Mercury User's Guide.

  Most of the information in the man pages is also available using
  the standard `--help' option.

* We've improved the compiler's diagnostics a bit.

  Some of the compiler's error messages are a bit more informative, and
  it catches some errors that previously it missed (such as specifiying
  modes in some but not all of the arguments of a `:- pred' declaration).

* We have made a few changes to the Mercury standard library.

  The changes are listed here, but see the library reference manual for
  details such as documentation on the new predicates.

  - The std_util.m module now contains functions and predicates for
    traversing and constructing terms of arbitrary type, and for
    accessing types at runtime.

    	For traversing terms: 
    		Predicates argument/3, det_argument/3, functor/3,
		and deconstruct/4.  These are similar to Prolog's arg/3,
		functor/3, and '=..'.

	For constructing terms:
		Functions num_functors/1, construct/3 and
		predicate get_functor/5.

	For accessing and constructing types:
		Functions type_of/1, type_ctor/1, type_args/1,
		type_ctor_name/1, type_ctor_arity/1, make_type/2,
		and predicates type_ctor_and_args/3 and
		type_ctor_name_and_arity/3.

    There are also some new functions for accessing values of the
    universal type `univ', namely univ/2 and univ_type/1.
    
  - We've finally implemented generic input-output predicates,
    namely io__print/3, io__write/3, and io__read/3,
    using the the functions and predicates described above.
    We've also added io__nl/3 to print a newline.
    Together with the change to make module qualifiers optional,
    these changes make performing output quite a bit simpler;
    it's nice that `print("Foo = "), print(Foo), nl' works now.

  - term_to_type/2 and type_to_term/2 are now implemented.

  - We have a new module called time.m XXX to make benchmarking easier.
    The predicate report_stats, which used to be in std_util, is now
    in this module.

  - The interface to the relation module has been changed extensively.
    Elements must now be explicitly added to the domain of the relation,
    using relation__add_element/4, and relation operations such as
    relation__add are now performed on relation_keys.  There are also
    four new operations which convert elements to relation_keys and
    vice versa:
	relation__search_element/3, relation__lookup_element/3,
	relation__search_key/3, and relation__lookup_key/3

  - set__subset XXX

  - We made some extensive additions to bag.m to include the standard set
    operations (union, intersection, subtraction), and some other predicates
    for manipulating bags.  We also changed bag__contains/2 (swapped the 
    arguments), and bag__remove (now semidet) to be consistent with set.m 
    and map.m. 

  - There are two new predicates `io__tmpnam' and `io__remove_file',
    with semantics similar to the ANSI C functions tmpnam() and remove().

  - There are new predicates `int__max_int', `int__min_int', 
    `int__bits_per_int', `char__min_char_value', `char__max_char_value',
    with semantics similar to INT_MAX, INT_MIN, (CHAR_BIT * sizeof(int)),
    CHAR_MIN, and CHAR_MAX in ANSI C (respectively).

  - We've added list__merge_and_remove_dups/4 and list__sort_and_remove_dups/4
    to complete the set of list__merge and list__sort operations.

  - We've added io__write_list/5 and io__write_list/6; these predicates write
    lists using a user-specified procedure to write the elements and separating
    the elements with a user-specified separator string.

  - We've add io__read_file/{3,4} and io__read_binary_file/{3,4} which read
    whole files (until error or eof).

  - We've added a double accumulator version of list__foldl/4 called
    list__foldl2/6, which is a convenient generalisation for accumulators
    that also do I/O. Also, we've added have list__map_foldl/5, which is an
    amalgam of list__map/3 and list__foldl/4.

  - We've added a new type of option data: maybe_string(maybe(string)). See
    library/getopt.m for details. Also added to getopt are some missing
    option-lookup predicates: getopt__lookup_accumulating_option/3 and
    getopt__lookup_maybe_string_option/3.

  - We've added string__foldl to the library. It has the same semantics as
    (string__to_char_list(String, Chars), list__foldl(Pred, Chars, Acc0, Acc))
    but is implemented more efficiently.

